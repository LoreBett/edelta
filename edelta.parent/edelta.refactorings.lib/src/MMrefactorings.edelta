import java.util.List
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature

package gssi.refactorings

def addMandatoryAttr(EClass eClass, String attrname, EDataType dataType): EAttribute {
	return eClass.addNewEAttribute(attrname, dataType) [
		lowerBound = 1;
	]
}

def mergeReferences(String newReferenceName, EClass newReferenceType, List<EReference> refs): EReference {
	refs.removeFeaturesFromContainingClass
	return newEReference(newReferenceName, newReferenceType)
}

def mergeAttributes(String newAttrName, EDataType newAttributeType, List<EAttribute> attrs) : EAttribute {
	attrs.removeFeaturesFromContainingClass
	return newEAttribute(newAttrName, newAttributeType)
}

def removeFeaturesFromContainingClass(List<? extends EStructuralFeature> features) {
	features
		.forEach[EContainingClass.EStructuralFeatures -= it]
}

def introduceSubclasses(EClass containingclass, EAttribute attr, EEnum enumType) {
	containingclass.abstract = true;
	for (subc : enumType.ELiterals) {
		containingclass.EPackage.addNewEClass(subc.literal) [
			addSuperClass(containingclass)
		];
		containingclass.EStructuralFeatures -= attr;
	}
}

/**
 * @param superclass where to pull up a single instance of the passed attributes
 * @param the attributes that are expected to be the same; the first element will be
 * pulled up in the superclass
 */
def extractSuperclass(EClass superclass, List<EAttribute> attrs){
	val extracted_attr = attrs.head;
	// print(extracted_attr.name);
	// already created from outside in the right package
	// extracted_attr.EContainingClass.EPackage.EClassifiers+=superclass;
	for (attr : attrs) {
		attr.EContainingClass => [
			// set supertype of the EClass of the attribute
			addSuperClass(superclass)
			// and then remove the attribute from the original EClass
			EStructuralFeatures -= attr
		]
	}

	superclass.EStructuralFeatures += extracted_attr;
}

/**
 * @param extractedClass the created EClass created representing the extracted metaclass
 * @param f 
 * @param inReferenceName
 * @param outReferenceName
 */
def extractMetaClass(EClass extractedClass, EReference f, String inReferenceName, String outReferenceName) : void {
	val ref_in = newEReference(inReferenceName, extractedClass) [
		lowerBound = f.EOpposite.lowerBound;
		upperBound = 1;
		// f.EOpposite.upperBound;
	];

	val old_ref = newEReference(f.name, f.EReferenceType) [
		lowerBound = 1;
		upperBound = 1;
		EOpposite = ref_in;
	];

	extractedClass.addEReference(old_ref);
	ref_in.EOpposite = old_ref;
	f.EOpposite.lowerBound = 1;
	f.EOpposite.upperBound = 1;

	extractedClass.addEReference(f.EOpposite);

	// already created from outside in the right package
	// f.EContainingClass.EPackage.EClassifiers+=extracted_class;
	f.EReferenceType.addEReference(ref_in);
	f.EType = extractedClass;
	f.containment = true;
	f.name = outReferenceName;
}
