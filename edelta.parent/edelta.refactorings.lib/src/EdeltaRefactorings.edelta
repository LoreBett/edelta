import java.util.List
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil

package edelta.refactorings.lib

def addMandatoryAttr(EClass eClass, String attrname, EDataType dataType): EAttribute {
	return eClass.addNewEAttribute(attrname, dataType) [
		lowerBound = 1;
	]
}

def mergeReferences(String newReferenceName, EClass newReferenceType, List<EReference> refs): EReference {
	refs.removeFeaturesFromContainingClass
	return newEReference(newReferenceName, newReferenceType)
}

def mergeAttributes(String newAttrName, EDataType newAttributeType, List<EAttribute> attrs) : EAttribute {
	attrs.removeFeaturesFromContainingClass
	return newEAttribute(newAttrName, newAttributeType)
}

def removeFeaturesFromContainingClass(List<? extends EStructuralFeature> features) {
	features
		.forEach[EContainingClass.EStructuralFeatures -= it]
}

def introduceSubclasses(EClass containingclass, EAttribute attr, EEnum enumType) {
	containingclass.abstract = true;
	for (subc : enumType.ELiterals) {
		containingclass.EPackage.addNewEClass(subc.literal) [
			addSuperClass(containingclass)
		];
		containingclass.EStructuralFeatures -= attr;
	}
}

/**
 * @param superclass where to pull up a single instance of the passed attributes
 * @param the attributes that are expected to be the same; the first element will be
 * pulled up in the superclass
 */
def extractSuperclass(EClass superclass, List<EAttribute> attrs){
	val extracted_attr = attrs.head;
	// print(extracted_attr.name);
	// already created from outside in the right package
	// extracted_attr.EContainingClass.EPackage.EClassifiers+=superclass;
	for (attr : attrs) {
		attr.EContainingClass => [
			// set supertype of the EClass of the attribute
			addSuperClass(superclass)
			// and then remove the attribute from the original EClass
			EStructuralFeatures -= attr
		]
	}

	superclass.EStructuralFeatures += extracted_attr;
}

/**
 * @param extractedClass the created EClass created representing the extracted metaclass
 * @param f 
 * @param inReferenceName
 * @param outReferenceName
 */
def extractMetaClass(EClass extractedClass, EReference f, String inReferenceName, String outReferenceName) : void {
	val ref_in = newEReference(inReferenceName, extractedClass) [
		lowerBound = f.EOpposite.lowerBound;
		upperBound = 1;
		// f.EOpposite.upperBound;
	];

	val old_ref = newEReference(f.name, f.EReferenceType) [
		lowerBound = 1;
		upperBound = 1;
		EOpposite = ref_in;
	];

	extractedClass.addEReference(old_ref);
	ref_in.EOpposite = old_ref;
	f.EOpposite.lowerBound = 1;
	f.EOpposite.upperBound = 1;

	extractedClass.addEReference(f.EOpposite);

	// already created from outside in the right package
	// f.EContainingClass.EPackage.EClassifiers+=extracted_class;
	f.EReferenceType.addEReference(ref_in);
	f.EType = extractedClass;
	f.containment = true;
	f.name = outReferenceName;
}

/**
 * Given a non empty list of {@link EStructuralFeature}, which are known to
 * appear in several classes as duplicates, extracts a new common superclass,
 * with the duplicate feature,
 * adds the extracted superclass to the classes with the duplicate
 * feature and removes the duplicate feature from each class.
 * 
 * @param duplicates
 */
def extractSuperclass(List<? extends EStructuralFeature> duplicates){
	val feature = duplicates.head;
	val containingEPackage = feature.EContainingClass.EPackage
	val superClassName =
		ensureEClassifierNameIsUnique(containingEPackage,
			feature.name.toFirstUpper + "Element"
		)

	val superclass = newEClass(superClassName) [
		abstract = true;
		EStructuralFeatures += EcoreUtil.copy(feature)
	]
	containingEPackage.EClassifiers += superclass

	for (duplicate : duplicates) {
		val eContainingClass = duplicate.EContainingClass
		// set supertype of the EClass of the attribute
		eContainingClass.ESuperTypes += superclass;
		// and then remove the attribute from the original EClass
		eContainingClass.EStructuralFeatures -= duplicate
	}
}

/**
 * Ensures that the proposed classifier name is unique within the specified
 * package; if not, it appends an incremental index until the name
 * is actually unique
 */
def ensureEClassifierNameIsUnique(EPackage ePackage, String proposedName) {
	var className = proposedName
	val currentEClassifiersNames =
		ePackage.EClassifiers.map[name].sort
	var counter = 1
	// make sure the new class is unique by name in the package
	while (currentEClassifiersNames.contains(className)) {
		className += (counter++)
	}
	return className
}
