grammar edelta.Edelta with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/xbase/Xbase" as xbase
import "http://www.eclipse.org/xtext/xbase/Xtype" as xtype
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

generate edelta "http://www.Edelta.edelta"

EdeltaProgram:
	{EdeltaProgram}
	('package' name=QualifiedName ';'?)?
	// semantic predicate required to avoid ambiguities with ';' of
	// the main expression
	=>importSection=XImportSection?
	('metamodel' metamodels+=[ecore::EPackage|STRING])*
	operations+=EdeltaOperation*
	main=EdeltaMain
;

// we need to add a semantic predicate here as well, for the same
// reason as above
XImportDeclaration returns xtype::XImportDeclaration:
	(=>'import' (
		(static?='static' extension?='extension'? importedType=[types::JvmDeclaredType|QualifiedNameInStaticImport] (wildcard?='*' | memberName=ValidID)) 
		| importedType=[types::JvmDeclaredType|QualifiedName] 
		| importedNamespace=QualifiedNameWithWildcard) ';'?)
;

EdeltaOperation:
	{EdeltaOperation} 'def' name=ValidID
		'(' (params+=FullJvmFormalParameter (',' params+=FullJvmFormalParameter)*)? ')'
		(':' type=JvmTypeReference)? 
		body=XBlockExpression;

EdeltaMain returns xbase::XBlockExpression:
	{EdeltaMain}
	(expressions+=XExpressionOrVarDeclaration ';'?)*
;

XPrimaryExpression returns xbase::XExpression:
	{EdeltaEClassifierExpression} 'eclassifier' eclassifier=[ecore::EClassifier] |
	{EdeltaEClassExpression} 'eclass' eclass=[ecore::EClass] |
	{EdeltaEDataTypeExpression} 'edatatype' edatatype=[ecore::EDataType] |
	{EdeltaEFeatureExpression} 'efeature' efeature=[ecore::EStructuralFeature] |
	{EdeltaEAttributeExpression} 'eattribute' eattribute=[ecore::EAttribute] |
	{EdeltaEReferenceExpression} 'ereference' ereference=[ecore::EReference] |
	super
;